(cl:in-package #:sicl-ast-evaluator)

;;; We need to start using DEFMACRO early on to define macros, and
;;; since we don't already have it, we must create it "manually".
;;; This version is incorrect, though, because it uses the host
;;; compiler both to create the macro function for DEFMACRO (which is
;;; fine) and for creating the macro function for the macros defined
;;; by DEFMACRO (which is not fine).  As a result, the macros defined
;;; by this version of DEFMACRO must be defined in the NULL lexical
;;; environment.  Luckily, most macros are, and certainly the ones we
;;; need to define with this version of DEFMACRO until we can replace
;;; it with a native version.
(defun define-defmacro (client environment)
  (setf (env:macro-function client environment 'defmacro)
        (compile nil
                 (cleavir-code-utilities:parse-macro
                  'defmacro
                  '(&environment env name lambda-list &body body)
                  `((eval-when (:compile-toplevel :load-toplevel :execute)
                      (setf (env:macro-function (client env) env name)
                            (compile nil
                                     (cleavir-code-utilities:parse-macro
                                      name
                                      lambda-list
                                      body)))))))))

;;; Eclector defines macros that are generated by the backquote
;;; facility.  These macros must exist in the global environment
;;; so that they can be expanded by the compiler.

(defun define-backquote-macros (client environment)
  (setf (env:fdefinition client environment 'eclector.reader::expand)
        (fdefinition 'eclector.reader::transform))
  (setf (env:macro-function client environment 'eclector.reader::quasiquote)
        (macro-function 'eclector.reader::quasiquote)))

(defun import-function (client environment function-name)
  (setf (env:fdefinition client environment function-name)
        (fdefinition function-name)))

(defun import-environment-functions (client environment)
  (do-external-symbols (symbol '#:env)
    (when (and (fboundp symbol)
               (null (macro-function symbol))
               (not (special-operator-p symbol)))
      (import-function client environment symbol))
    (when (fboundp `(setf ,symbol))
      (import-function client environment `(setf ,symbol)))))

(defun load-file (relative-filename environment)
  (let ((*package* *package*)
        (filename (asdf:system-relative-pathname
                   '#:sicl relative-filename)))
    (sicl-source-tracking:with-source-tracking-stream-from-file
        (stream filename)
      (let ((first-form (eclector.reader:read stream nil nil)))
        (unless (eq (first first-form) 'in-package)
          (error "File must start with an IN-PACKAGE form."))
        (setf *package* (find-package (second first-form))))
      (loop with eof-marker = (list nil)
            for cst = (eclector.concrete-syntax-tree:read stream nil eof-marker)
            until (eq cst eof-marker)
            do (eval cst environment)))))

(defun host-load (relative-filename)
  (let ((filename (asdf:system-relative-pathname
                   '#:sicl relative-filename)))
    (load filename)))

(defun fill-environment (environment)
  (let ((client (client environment)))
    (define-defmacro client environment)
    (define-backquote-macros client environment)
    (import-environment-functions client environment)
    (flet ((ld (relative-file-name)
             (format *trace-output* "Loading file ~a~%" relative-file-name)
             (load-file relative-file-name environment)))
      (host-load "Evaluation-and-compilation/packages.lisp")
      ;; Load a file containing a definition of the macro LAMBDA.
      ;; This macro is particularly simple, so it doesn't really
      ;; matter how it is expanded.  This is fortunate, because at the
      ;; time this file is loaded, the definition of DEFMACRO is still
      ;; one we created "manually" and which uses the host compiler to
      ;; compile the macro function in the null lexical environment.
      ;; We define the macro LAMBDA before we redefine DEFMACRO as a
      ;; target macro because PARSE-MACRO returns a LAMBDA form, so we
      ;; need this macro in order to redefine DEFMACRO.
      (ld "Evaluation-and-compilation/lambda.lisp"))))
