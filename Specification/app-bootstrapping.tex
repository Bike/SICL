\chapter{Bootstrapping principles}

In this appendix, we describe general principles of bootstrapping, as
opposed to implementation details.

\section{General restrictions}

We define the \emph{purity} of some object to be a non-negative
integer.  An object of purity $p$ is an instance of a class of purity
$p-1$.  An object of purity $0$ is a \emph{host object}.  An object of
purity $1$ is a is a \emph{bridge object}.  An object of purity $2$ is
an \emph{impure ersatz object}.  An object of purity $3$ or more is a
\emph{pure ersatz object}.

Suppose we want to access some part of a generic function metaobject
of purity $p$.  Perhaps we want to add methods to it, or set its
discriminating function.  During bootstrapping, such access must be
done by fully functioning generic functions.  For that reason, we use
functions of purity $p-1$ for such access, and we can assume that when
we need to accomplish such access to a generic function of purity $p$,
then either the accessors of purity $p-1$ are either already fully
functional, or the machinery for making them fully functional is fully
functional, so that we can freely use generic functions of purity
$p-1$ to access a generic function of purity $p$.

More generally, we assume that the arguments to a generic function of
purity $p$ are objects of purity $p+1$.  It follows that the
\emph{specializers} of a generic function of purity $p$ are objects of
purity $p$ as well, since they are typically the classes of the
arguments.  Since the arguments have purity $p+1$, their classes are
objects of purity $p$.  Furthermore we want the methods of a generic
function of purity $p$ to be objects of purity $p$, and we want the
method functions of those methods to be objects of purity $p$.  Idem
for the \emph{method combination}, the \emph{effective method
  functions}, and the \emph{discriminating function}.  It follows that
the \emph{generic-function class} and the \emph{method class} of a
generic function of purity $p$ are objects of purity $p-1$.

In general, we would like for a function of purity $p$ to call other
functions of purity $p$, but during bootstrapping we can not always
accomplish this restriction.  As a general principle, however, we want
to minimize the exceptions to this rule, because these exceptions
require specific bootstrapping code to be handled correctly.

\section{Object allocation}

Suppose we want to allocate an object of purity $p$.  To do so, we
need to instantiate a class of purity $p-1$.  Instantiating a class
involves calling \texttt{allocate-instance}, which is a generic
function.  Since \texttt{allocate-instance} is a generic function that
takes an object of purity $p-1$ as an argument, it must be a generic
function of purity $p-2$.  Furthermore, \texttt{allocate-instance}
must call accessor generic functions to inspect the class metaobject
in order to determine the \emph{unique number} of the class as well as
its list of slot metaobjects, and information about the size of its
instances.  All these accessors are objects of purity $p-2$ as well.

Now \texttt{allocate-instance} was called by \texttt{make-instance}
which is a generic function.  Assume for the moment that
\texttt{make-instance} was given a class metaobject to instantiate.
Then \texttt{make-instance} must also be of purity $p-2$.

\section{Object initialization}

After \texttt{make-instance} has called \texttt{allocate-instance}, it
calls \texttt{initialize-instance}, giving it the newly allocated
instance and some key/value pairs.  \texttt{initialize-instance} is
thus a generic function that takes an object of purity $p$, and it
follows that \texttt{initialize-instance} is a generic function of
purity $p-1$.  We therefore have a case where a generic function
(i.e. \texttt{make-instance}) of purity $p-2$ calls a generic function
of purity $p-1$.
